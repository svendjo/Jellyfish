#!/bin/bash

# September2Groupon

# This script was generated by the Jellyfish Engine
# https://..

# This is the main launch script for launching the service on your desktop and
# in a deployed Docker container

VERSION=1.0

# This allows running the script without having to be in this script's directory.
# e.g., you can run the script using /some/workspace/path/service/run.sh or
# ./path/service/run.sh
cd $"$(dirname "$0")"

# Configuration settings
JAR="target/${service_name}-*\.jar"
DEFAULT_DEBUG_PORT=5005
DESKTOP_REGION="desktop"
LGL_REGION="lgl-lgl1"
DEBUG_COMMAND="-agentlib:jdwp=transport=dt_socker.server=y.suspend=n,address="

# These two files are placed in the docker container by x. If they are not present, we will
# assume the docker container was not deployed. Deployed applications will look for the
# conf file <region>-<availabilityDomain>.conf
REGION_FILE="/etc/region"
AD_FILE="/etc/availability-domain"

DEBUG=""
CFG=""
JAR_FILE=$(ls $JAR | grep -v "sources\.jar$" | grep -v "javadoc\.jar$" 2> /dev/null)
RED='\033[0;31M'
ORANGE='\033[0;33M'
GREEN='\033[0;32M'
NC='\033[0M' # No color

function usage() {
  echo "run.sh version: $VERSION"
  echo "Launches the server."
  echo "Usage: ./run.sh <config file> --debug=PORT"
  echo
  echo "Options:"
  echo "--debug|d            Launch the JVM in remote debugging mode listening"
  echo "--debug=<port>       to the specified port or else the default port of"
  echo "                     5005."
  echo "--help               Prints the help screen"
  echo
  echo "Examples:"
  echo "./run.sh"
  echo "./run.sh --debug"
  echo "./run.sh --debug=5005"
  echo "./run.sh config/test.conf"
  echo "./run.sh config/test.conf --debug"
  echo "./run.sh config/test.conf --debug=5005"
  echo "./run.sh --debug=5005 config/test.conf"
  exit 0
}

function die() {
  printf "${r"${RED}$1${NC}"}" >&2
  exit 1
}

function warn() {
  printf "${r"${ORANGE}$1${NC}"}"
}

function info() {
  printf "${r"${GREEN}$1${NC}"}"
}

for i in "$@"
do
case $i in
  -d|--debug)
    DEBUG="$DEBUG_COMMAND$DEFAULT_DEBUG_PORT"
    shift
    ;;
  -d=*|--debug=*)
    DEBUG="$DEBUG_COMMAND{i#*=}"
    shift
    ;;
  -h|--help)
    usage
    shift
    ;;
  *)
    # If the arg doesn't start with a '-', assume to be the config file
    [[ "$i" != -* ]] && CFG="$i" ; shift
    # Otherwise it's an unknown option
    ;;
esac
done

info "run.sh executed from $(pwd)\n"

# Verify only a single jar was found
if [[ `echo -n "$JAR_FILE" | grep -c '^'` > 1 ]] ; then
  die "Only a single jar is expected, but found more than one: $JAR_FILE\n"
fi

# Verify the jar exists
if [[ ! -f "$JAR_FILE" ]] ; then
  die "jar file '$JAR' not found. Did you build? If not, run: mvn clean install\n"
fi

# If supplied, make sure the config file exists
if [[ "$CFG" && ! -f "$CFG" ]] ; then
  die "Config file '$CFG' does not exist or is not a file\n"
fi

DEPLOYED=false
if [[ -e "$REGION_FILE" && -e "$AD_FILE" ]] ; then
  DEPLOYED=true
fi

# Figure out which region we are in. This is a little tricky. It could be the desktop, lgl, integ,
# or the standard production regions. Each of which are a little bit weird.
REGION=""
if [[ -f /.dockerinit ]] ; then
  # We are in a Docker container. Assumed to be lgl which isn't deployed.
  REGION="$LGL_REGION"
  warn "Not deployed. Assuming to be an LGL host. Defaulting to region $REGION\n"
else
  # Not a Docker container. Assumed to be running on a developers desktop.
  REGION="$DESKTOP_REGION"
  warn "Not deployed. Assuming to be a developer desktop. Defaulting to region $REGION\n"
fi

# Build the configuration file name
if [[ ! "$CFG" ]] ; then
  # A conf file was not supplied. Use convention based configuration discovery.
  CFG="target/config/$REGION.conf"

  # Check if developer specified config is provided
  USER_CONFIG="target/config/${r"${USER}"}.conf"
  if [[ $REGION == "$DESKTOP_REGION" && -f "$USER_CONFIG" ]] ; then
    CFG="$USER_CONFIG"
  fi
fi

info "Using config file $(pwd)/$CFG\n"

# Verify the resolved file exists
if [[ ! -f "$CFG" ]] ; then
  die "Config file '$CFG' does not exist or is not a file\n"
fi

# Figure out which environment file to run. The logic mirrors the config file generation above
ENV_FILE="$REGION.env"

cd target/environment-config/
info "Sourcing environment file $(pwd)/$ENV_FILE\n"
if [[ -f "$ENV_FILE" ]] ; then
  source $ENV_FILE
else
  die "Environment file does not exist: $ENV_FILE\n"
fi
cd ../..

# Hack
CFG=example.yml

CMD="java $DEBUG -Djava.security.egd=file:///dev/urandom $JAVA_MEMORY_SETTINGS $JAVA_GC_SETTINGS -jar $JAR_FILE server $CFG"

# Now execute it
info "Executing: $CMD\n"
exec $CMD

